<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MacroSim | v19.4 Final Fix</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-body: #0f172a; --bg-panel: #1e293b; --bg-sidebar: #020617;
            --border: #334155; --text-main: #f1f5f9; --text-muted: #94a3b8;
            --accent: #6366f1; --warn: #f59e0b;
            --grid-line: #334155; --axis-line: #94a3b8;
        }
        :root.light-mode {
            --bg-body: #ffffff; --bg-panel: #f8fafc; --bg-sidebar: #f1f5f9;
            --border: #cbd5e1; --text-main: #0f172a; --text-muted: #475569;
            --grid-line: #e2e8f0; --axis-line: #64748b;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-body); color: var(--text-main); margin: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }
        header {
            height: 50px; padding: 0 20px; background-color: var(--bg-sidebar); border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .brand { font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 10px; }
        .tag { background: var(--accent); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; }
        .layout { display: flex; flex: 1; height: calc(100vh - 50px); }
        .sidebar {
            width: 360px; background-color: var(--bg-sidebar); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; overflow-y: auto;
        }
        .section-title {
            padding: 16px 20px 8px; font-size: 0.7rem; text-transform: uppercase;
            color: var(--text-muted); font-weight: 700; letter-spacing: 1px; border-top: 1px solid var(--border);
        }
        .section-title:first-child { border-top: none; }
        .model-list { list-style: none; padding: 0; margin: 0; }
        .model-btn {
            width: 100%; text-align: left; padding: 12px 20px; background: transparent; border: none;
            color: var(--text-muted); cursor: pointer; border-left: 3px solid transparent; font-size: 0.9rem;
            transition: all 0.2s;
        }
        .model-btn:hover { background: var(--bg-panel); color: var(--text-main); }
        .model-btn.active { background: var(--bg-panel); color: var(--text-main); border-left-color: var(--accent); font-weight: 600; }
        
        .controls-container { padding: 10px 20px; }
        .slider-group { margin-bottom: 16px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; margin-bottom: 8px; }
        .label-wrap { display: flex; align-items: center; gap: 8px; }
        .info-btn {
            display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px;
            border-radius: 50%; background: var(--border); color: var(--text-muted); font-size: 10px; font-weight: bold;
            font-family: serif; font-style: italic; cursor: help; position: relative;
        }
        .info-btn:hover { background: var(--accent); color: white; }
        .tooltip-box {
            position: absolute; bottom: 120%; left: -10px; background: var(--bg-sidebar); border: 1px solid var(--border);
            color: var(--text-main); padding: 10px; border-radius: 6px; font-size: 0.75rem; width: 240px;
            z-index: 1000; display: none; box-shadow: 0 10px 25px rgba(0,0,0,0.2); pointer-events: none; line-height: 1.4;
        }
        .info-btn:hover .tooltip-box { display: block; }
        .slider-val { font-family: monospace; color: var(--accent); }
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; padding: 0 5px; }
        .toggle-label { font-size: 0.8rem; color: var(--text-main); }
        .switch { position: relative; display: inline-block; width: 34px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border); transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(14px); }

        .scenario-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 0 20px 20px; }
        .scenario-btn {
            background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-muted); padding: 8px;
            border-radius: 6px; font-size: 0.7rem; cursor: pointer; transition: all 0.2s; text-align: center;
        }
        .scenario-btn:hover { border-color: var(--accent); color: var(--text-main); background: var(--border); }
        
        .sim-controls {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            display: flex; gap: 8px;
        }
        .sim-btn {
            background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-main);
            padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border-radius: 6px; font-weight: 600;
        }
        .sim-btn:hover { background: var(--accent); color: white; border-color: var(--accent); }
        .reset-btn {
            width: calc(100% - 40px); margin: 0 20px 20px 20px; padding: 10px; background: transparent;
            border: 1px dashed var(--border); color: var(--text-muted); cursor: pointer; border-radius: 6px;
            font-size: 0.8rem; transition: all 0.2s;
        }
        .reset-btn:hover { border-color: var(--accent); color: var(--text-main); background: rgba(99, 102, 241, 0.1); }
        
        .viz-panel {
            flex: 2; position: relative; display: flex; flex-direction: column; background: var(--bg-body); overflow: hidden;
            transition: background-color 0.3s;
        }

        .horizon-tabs {
            position: absolute; top: 15px; right: 15px; z-index: 10;
            display: flex; background: var(--bg-panel); padding: 4px; border-radius: 8px; border: 1px solid var(--border);
        }
        .tab-btn {
            background: transparent; border: none; color: var(--text-muted); padding: 6px 12px;
            font-size: 0.8rem; cursor: pointer; border-radius: 6px;
        }
        .tab-btn.active { background: var(--accent); color: white; }
        
        canvas { width: 100%; height: 100%; }
        .edu-panel {
            width: 320px; background-color: var(--bg-body); border-left: 1px solid var(--border);
            display: flex; flex-direction: column; overflow-y: auto; padding: 20px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .edu-card { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .edu-title { font-weight: 700; font-size: 0.85rem; margin-bottom: 10px; color: var(--text-main); border-bottom: 1px solid var(--border); padding-bottom: 8px; }
        .math-block { font-size: 0.8rem; color: var(--text-muted); line-height: 1.6; overflow-x: auto; }
        .analysis-text { font-size: 0.85rem; color: var(--text-muted); line-height: 1.5; }
        
        .stats-overlay { position: absolute; top: 60px; right: 15px; display: flex; gap: 10px; z-index: 10; }
        .stat-box { background: var(--bg-panel); border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; text-align: right; box-shadow: 0 4px 6px rgba(0,0,0,0.1); opacity: 0.95; }
        .stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
        .stat-num { font-size: 0.95rem; font-weight: 700; color: var(--text-main); font-family: monospace; }
        .warning-banner {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            background: rgba(245, 158, 11, 0.15); border: 1px solid var(--warn); color: var(--warn);
            padding: 8px 16px; border-radius: 99px; font-size: 0.75rem; font-weight: 600;
            pointer-events: none; display: none; backdrop-filter: blur(4px);
        }
        #legend-content { display: flex; flex-direction: column; gap: 8px; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 0.8rem; color: var(--text-muted); }
        .legend-line { width: 16px; height: 3px; border-radius: 2px; }
        .creator-mark { margin-top: auto; padding-top: 20px; text-align: right; font-size: 10px; color: var(--text-muted); opacity: 0.5; font-family: serif; font-style: italic; letter-spacing: 0.5px; }
        .theme-toggle {
            background: transparent; border: 1px solid var(--border); color: var(--text-main);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; margin-right: 15px;
            display: flex; align-items: center; gap: 6px;
        }
        .theme-toggle:hover { background: var(--bg-panel); }
    </style>
</head>
<body>

<header>
    <div class="brand">
        <div class="brand-icon">üìà</div>
        MACRO SIMULATOR <span class="tag">v19.4</span>
    </div>
    <div style="display:flex; align-items:center;">
        <button class="theme-toggle" id="theme-btn" onclick="toggleTheme()">‚òÄÔ∏è Projector Mode</button>
    </div>
</header>

<div class="layout">
    <nav class="sidebar">
        <div class="section-title">Select Model</div>
        <ul class="model-list">
            <li><button class="model-btn active" onclick="switchModel('islm', this)">IS-LM Model</button></li>
            <li><button class="model-btn" onclick="switchModel('adas', this)">AD-AS Model</button></li>
            <li><button class="model-btn" onclick="switchModel('phillips', this)">Phillips Curve</button></li>
            <li><button class="model-btn" onclick="switchModel('solow', this)">Solow Growth</button></li>
            <li><button class="model-btn" onclick="switchModel('mundell', this)">Mundell-Fleming</button></li>
        </ul>
        <div class="section-title">Parameters</div>
        <div class="controls-container" id="controls"></div>
        <div class="section-title">Quick Scenarios</div>
        <div class="scenario-grid" id="scenarios"></div>
        <button class="reset-btn" onclick="resetModel()">‚ü≤ Reset to Baseline</button>
    </nav>

    <main class="viz-panel">
        <div class="sim-controls" id="sim-ctrl" style="display:none;">
            <button class="sim-btn" onclick="stepSim()">‚ñ∂ Evolve Expect./Capital</button>
        </div>
        
        <div class="horizon-tabs" id="horizon-ctrl">
            <button class="tab-btn active" onclick="setHorizon('short', this)">Short Run</button>
            <button class="tab-btn" onclick="setHorizon('medium', this)">Medium</button>
            <button class="tab-btn" onclick="setHorizon('long', this)">Long Run</button>
        </div>

        <div class="stats-overlay" id="stats"></div>
        <div class="warning-banner" id="warning">‚ö†Ô∏è Parameter Warning</div>
        <canvas id="canvas"></canvas>
    </main>

    <aside class="edu-panel">
        <div class="edu-card">
            <div class="edu-title">Theory & Derivation</div>
            <div class="math-block" id="math-display"></div>
        </div>
        <div class="edu-card">
            <div class="edu-title">Equilibrium Analysis</div>
            <div class="analysis-text" id="analysis-text"></div>
        </div>
        <div class="edu-card">
            <div class="edu-title">Legend</div>
            <div id="legend-content"></div>
        </div>
        <div class="creator-mark">Created by Bence Rudolph</div>
    </aside>
</div>

<script>
/* ==========================================================================
   THEME & UTILS
   ========================================================================== */
function toggleTheme() {
    const root = document.documentElement;
    const btn = document.getElementById('theme-btn');
    if (root.classList.contains('light-mode')) {
        root.classList.remove('light-mode'); btn.innerText = "‚òÄÔ∏è Projector Mode";
    } else {
        root.classList.add('light-mode'); btn.innerText = "üåô Dark Mode";
    }
    update();
}
function getVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* ==========================================================================
   GLOBAL CONSTANTS & STATE
   ========================================================================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const PARAMS = { 
    c1: 0.75, c0: 10, I0: 20, b: 10, k: 0.5, h: 2.0, Yn: 100, 
    m: 0.15, X0: 20, beta: 0.5, alpha: 0.33 
};

/* DEFAULTS */
const DEFAULTS = {
    islm: { G: 70, T: 60, M: 50, isOpen: false },
    adas: { G: 60, M: 50, Pe: 1.0, P: 1.0 },
    solow: { s: 0.3, d: 0.1, n: 0.02, g: 0.02, k: 20 },
    mundell: { G: 60, M: 50, rs: 4.0, regime: 'float' },
    phillips: { Pie: 2.0, Un: 5.0, demandGap: 0, shock: 0.0, adaptive: false }
};

let state = JSON.parse(JSON.stringify(DEFAULTS.islm));
state.model = 'islm';
state.horizon = 'short';
let prevState = JSON.parse(JSON.stringify(DEFAULTS.islm));
let view = { maxX: 350, maxY: 25 }; 
let warningMsg = null;

/* ==========================================================================
   MODEL ENGINES
   ========================================================================== */
const MODELS = {
    islm: {
        name: "IS-LM (Keynesian)",
        legend: [
            {label: 'IS Curve', color: '#3b82f6'},
            {label: 'LM Curve', color: '#ef4444'},
            {label: 'Natural Output (Yn)', color: '#94a3b8', dashed: true}
        ],
        scenarios: [
            { name: "Fiscal Stimulus", apply: {G:120} },
            { name: "Monetary Tightening", apply: {M:25} },
            { name: "Liquidity Trap Case", apply: {M:120, G:30} }
        ],
        solve: (st) => {
            let { G, T, M, isOpen, horizon } = st;
            G=Math.min(200,Math.max(10,G)); M=Math.max(10,M);
            const { c1, c0, I0, b, m, X0, Yn } = PARAMS;
            const r_min = 0.1; // Trap floor

            const mult = isOpen ? 1/(1 - c1 + m) : 1/(1 - c1);
            const Aut = c0 + I0 + G - c1*T + (isOpen ? X0 : 0);
            
            // IS Curve Function: Y = mult(Aut - b*r) -> r = (Aut - Y/mult)/b
            
            let Y, r;
            
            if (horizon === 'long') {
                // LONG RUN: Y fixed at Yn. Prices adjust LM to meet intersection.
                Y = Yn;
                r = (Aut - Y/mult) / b; // r determined by IS at Yn
                // M/P = kY - hr -> P = M / (kY - hr). P implicit.
                // We fake the M effect for drawing by calculating an effective M that puts LM at intersection
                // Effective M = k*Y - h*r
                // But in drawing we use 'M' and 'P=1'. So we just replace M with M_eff in return object.
                const M_eff = PARAMS.k*Y - PARAMS.h*r;
                // Override M for the drawing phase to show the shifted LM
                return { Y, r, Aut, mult, M: M_eff, type: 'islm', horizon };
            } 
            else {
                // SHORT & MEDIUM RUN: Price fixed (or sticky). Standard IS-LM.
                // Medium run in pure IS-LM is often just transition, we treat as SR here for simplicity
                // unless we want to show partial P adjustment. Let's keep it SR logic for stability.
                
                // 1. Solve Normal Eq
                const denom = 1 + (mult * b * PARAMS.k) / PARAMS.h;
                const num = mult * (Aut + (b * M)/PARAMS.h);
                Y = num / denom;
                r = (PARAMS.k*Y - M)/PARAMS.h;
                
                // 2. Liquidity Trap Regime (Decoupling)
                if(r < r_min) {
                    r = r_min;
                    Y = mult * (Aut - b*r_min);
                    warningMsg = "Liquidity Trap: Mon. Policy Ineffective";
                }
                return { Y, r, Aut, mult, M, type: 'islm', horizon };
            }
        },
        draw: (sol, isGhost) => {
            const sIS = isGhost ? 'ghost' : 'is';
            const sLM = isGhost ? 'ghost' : 'lm';
            
            // IS Curve
            drawCurve(y => (sol.Aut - y/sol.mult)/PARAMS.b, sIS, isGhost?'IS‚ÇÄ':'IS‚ÇÅ');
            
            // LM Curve with clean floor
            // kinkY is where LM hits r=0.1
            // (kY - M)/h = 0.1 => kY - M = 0.1h => Y = (M + 0.1h)/k
            const kinkY = (sol.M + PARAMS.h*0.1)/PARAMS.k;
            drawCurve(y => {
                if(y <= kinkY) return 0.1;
                return (PARAMS.k*y - sol.M)/PARAMS.h;
            }, sLM, isGhost?'LM‚ÇÄ':'LM‚ÇÅ');
            
            if(!isGhost) drawDot(sol.Y, sol.r);
            if(sol.horizon === 'long' && !isGhost) drawVertical(PARAMS.Yn, '#94a3b8', 'Yn');
        },
        explain: (sol) => {
            const hText = sol.horizon==='long' ? "(Long Run: Output fixed, Prices adjust)" : "(Short Run: Prices fixed)";
            return `$$ \\text{IS-LM } ${hText} $$ 
                    $$ Y = ${sol.Y.toFixed(1)}, r = ${sol.r.toFixed(2)}\\% $$`;
        }
    },

    adas: {
        name: "AD-AS (Dynamic)",
        legend: [
            {label: 'AD Curve', color: '#10b981'},
            {label: 'SRAS Curve', color: '#f59e0b'},
            {label: 'LRAS (Yn)', color: '#94a3b8', dashed: true}
        ],
        scenarios: [
            { name: "Demand Shock", apply: {G:100} },
            { name: "Supply Shock", apply: {Pe: 2.0} }
        ],
        solve: (st) => {
            const { c1, c0, I0, b, k, h, Yn } = PARAMS;
            const mult = 1/(1-c1);
            const Aut = c0 + I0 + st.G - c1*DEFAULTS.islm.T; 
            const theta = (h + b*k*mult); 
            const term1 = (h * mult * Aut) / theta; 
            const term2 = (b * mult * st.M) / theta; 
            
            let Y_eq, P_eq, lambda;

            if (st.horizon === 'long') {
                // LONG RUN: Y = Yn. AD determines P.
                // Y = term1 + term2/P => P = term2 / (Yn - term1)
                Y_eq = Yn;
                P_eq = term2 / (Yn - term1);
                // Vertical AS
                lambda = 1000; // effective vertical slope
            } 
            else if (st.horizon === 'short') {
                // SHORT RUN: Horizontal AS at Pe (Sticky Price)
                P_eq = st.Pe;
                Y_eq = term1 + term2/P_eq;
                lambda = 0; // Horizontal slope
            } 
            else {
                // MEDIUM RUN: Upward sloping AS
                lambda = 0.5;
                const B_quad = st.Pe + lambda*(term1 - Yn);
                const C_quad = -lambda * term2;
                P_eq = (B_quad + Math.sqrt(Math.max(0, B_quad*B_quad - 4*1*C_quad))) / 2;
                Y_eq = term1 + term2/P_eq;
            }

            return { Y: Y_eq, P: P_eq, term1, term2, Pe: st.Pe, Yn, lambda, type:'adas', horizon: st.horizon };
        },
        draw: (sol, isGhost) => {
            // AD Curve: P = term2 / (Y - term1)
            drawCurve(y => {
                let den = y - sol.term1;
                return den > 0.1 ? sol.term2/den : null;
            }, isGhost?'ghost':'ad', isGhost?'AD‚ÇÄ':'AD‚ÇÅ');

            // AS Curve
            if (sol.horizon === 'long') {
                // Vertical AS at Yn
                drawVertical(PARAMS.Yn, isGhost?'ghost':'#f59e0b', isGhost?'LRAS‚ÇÄ':'LRAS‚ÇÅ');
            } else {
                // Upward or Horizontal AS
                // P = Pe + lambda(Y - Yn)
                drawCurve(y => sol.Pe + sol.lambda*(y - PARAMS.Yn), isGhost?'ghost':'as', isGhost?'SRAS‚ÇÄ':'SRAS‚ÇÅ');
            }
            
            if(!isGhost) drawDot(sol.Y, sol.P);
        },
        explain: (sol) => `$$ P = P^e + \\lambda(Y - Y_n) \\quad [\\lambda=${sol.lambda}] $$ 
                           $$ Y = AD(G, M/P) $$`
    },

    phillips: {
        name: "Phillips Curve",
        legend: [
            {label: 'Short-Run PC', color: '#ef4444'},
            {label: 'Long-Run PC', color: '#3b82f6', dashed: true}
        ],
        scenarios: [
            { name: "Demand Boom", apply: {demandGap: 3.0} },
            { name: "Supply Shock", apply: {shock: 2.0} }
        ],
        solve: (st) => {
            const u = st.Un - 0.5 * st.demandGap;
            const Pi = st.Pie - PARAMS.beta*(u - st.Un) + st.shock;
            return { u, Pi, Pie: st.Pie, Un: st.Un, type:'phillips' };
        },
        step: () => {
            if(state.adaptive) {
                const sol = MODELS.phillips.solve(state);
                const gamma = 0.2; 
                state.Pie = state.Pie + gamma * (sol.Pi - state.Pie);
                update();
            }
        },
        draw: (sol, isGhost) => {
            const intercept = sol.Pie + state.shock + PARAMS.beta*sol.Un;
            drawCurve(u => intercept - PARAMS.beta*u, isGhost?'ghost':'lm', isGhost?'PC‚ÇÄ':'PC‚ÇÅ');
            drawVertical(sol.Un, '#3b82f6', 'LRPC');
            if(!isGhost) drawDot(sol.u, sol.Pi);
        },
        explain: (sol) => `$$ \\pi_t = \\pi^e_{t} - \\beta(u_t - u_n) + \\nu_t $$`
    },

    solow: {
        name: "Solow-Swan",
        legend: [
            {label: 'Investment sf(k)', color: '#10b981'},
            {label: 'Break-even (Œ¥+n+g)k', color: '#ef4444'}
        ],
        scenarios: [
            { name: "Savings Boom", apply: {s: 0.5} },
            { name: "Tech Growth", apply: {g: 0.05} }
        ],
        solve: (st) => {
            const effDep = st.d + st.n + st.g;
            const k_star = Math.pow(st.s/effDep, 1/(1-PARAMS.alpha));
            const y_curr = Math.pow(st.k, PARAMS.alpha);
            return { k_star, effDep, k_curr: st.k, y_curr, type:'solow' };
        },
        step: () => {
            const sol = MODELS.solow.solve(state);
            const dk = state.s * sol.y_curr - sol.effDep * state.k;
            state.k += dk * 1.5; 
            update();
        },
        draw: (sol, isGhost) => {
            drawCurve(k => state.s * Math.pow(k, PARAMS.alpha), isGhost?'ghost':'ad', 'sf(k)');
            drawCurve(k => sol.effDep * k, isGhost?'ghost':'lm', '(Œ¥+n+g)k');
            if(!isGhost) {
                drawDot(sol.k_curr, state.s * Math.pow(sol.k_curr, PARAMS.alpha));
                const y_star = state.s * Math.pow(sol.k_star, PARAMS.alpha);
                ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); 
                const [sx, sy] = toScreen(sol.k_star, y_star);
                ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
            }
        },
        explain: (sol) => `$$ \\Delta k = s f(k) - (\\delta + n + g)k $$`
    },

    mundell: {
        name: "Mundell-Fleming (SOE)",
        legend: [
            {label: 'IS* Curve', color: '#3b82f6'},
            {label: 'LM* Curve (Vertical)', color: '#ef4444'}
        ],
        scenarios: [
            { name: "Fiscal Exp. (Float)", apply: {G:100, regime:'float'} },
            { name: "Fiscal Exp. (Fixed)", apply: {G:100, regime:'fixed'} }
        ],
        solve: (st) => {
            // Y vs Exchange Rate (e) model
            const { c1, c0, I0, b, X0 } = PARAMS;
            const Aut = c0 + I0 + st.G - c1*60;
            const r_star = st.rs; 
            const q = 2; // e sensitivity
            let Y, e, M_endo;

            if(st.regime === 'float') {
                // Float: M is fixed -> Y is fixed by LM* (Vertical)
                // Y = (M + h*r*)/k
                M_endo = st.M;
                Y = (M_endo + PARAMS.h*r_star) / PARAMS.k;
                
                // IS*: Y(1-c1) = Aut - b*r* + X0 - q*e
                // q*e = Aut - b*r* + X0 - Y(1-c1)
                e = (Aut - b*r_star + X0 - Y*(1-c1)) / q;
            } else {
                // Fixed: e is fixed -> IS* determines Y (Vertical LM* must shift to match)
                e = 3.0; // Pegged rate
                Y = (Aut - b*r_star + X0 - q*e) / (1-c1);
                M_endo = PARAMS.k*Y - PARAMS.h*r_star;
            }
            // Capture G, T, etc. for ghost curves
            return { Y, e, r: r_star, M: M_endo, regime: st.regime, G: st.G, type:'mundell' };
        },
        draw: (sol, isGhost) => {
            // Vertical LM*: x = Y
            drawVertical(sol.Y, isGhost?'#ef4444':'#ef4444', isGhost?'LM*‚ÇÄ':'LM*‚ÇÅ');
            
            // Downward IS*: e = (Aut... - Y(1-c1))/q
            const q = 2;
            const { c1, c0, I0, b, X0 } = PARAMS;
            // Use snapshot G from sol object
            const A_tot = c0 + I0 + sol.G - c1*60 + X0 - b*sol.r;
            
            // Draw IS* in (Y, e) space
            drawCurve(y => (A_tot - y*(1-c1))/q, isGhost?'ghost':'is', isGhost?'IS*‚ÇÄ':'IS*‚ÇÅ');
            
            if(!isGhost) drawDot(sol.Y, sol.e);
        },
        explain: (sol) => {
            return `$$ \\text{Float: } \\Delta G \\to \\Delta e \\quad \\text{Fixed: } \\Delta G \\to \\Delta Y (\\Delta M) $$
                    $$ e = ${sol.e.toFixed(2)} \\quad Y = ${sol.Y.toFixed(1)} $$`;
        }
    }
};

/* ==========================================================================
   VIEW & CONTROLS
   ========================================================================== */
function calculateViewWindow(sol) {
    if(sol.type === 'solow') { view.maxX = 60; view.maxY = 6; }
    else if(sol.type === 'phillips') { view.maxX = 12; view.maxY = 10; } 
    else if(sol.type === 'adas') { view.maxX = 300; view.maxY = 5; }
    else if(sol.type === 'mundell') { view.maxX = 350; view.maxY = 8; } 
    else { view.maxX = 350; view.maxY = 15; } 
}

function toScreen(x, y) {
    const pad = 60; const w = canvas.width; const h = canvas.height;
    const sX = pad + (x / view.maxX) * (w - 2*pad);
    const sY = (h - pad) - (y / view.maxY) * (h - 2*pad);
    return [sX, sY];
}

function drawCurve(func, style, label) {
    const colors = { is: '#3b82f6', lm: '#ef4444', ad: '#10b981', as: '#f59e0b', ghost: '#475569' };
    const pad = 60;
    ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, canvas.width-2*pad, canvas.height-2*pad); ctx.clip();
    ctx.beginPath(); ctx.strokeStyle = colors[style] || '#fff';
    ctx.lineWidth = style === 'ghost' ? 2 : 3;
    if(style === 'ghost') ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
    
    let start = true;
    for(let i = 0; i <= 600; i++) {
        const x = (i/600) * view.maxX;
        const y = func(x);
        if(y === null || !isFinite(y) || y < -5 || y > view.maxY*1.5) { start=true; continue; }
        const [sx, sy] = toScreen(x, y);
        if(start) { ctx.moveTo(sx, sy); start=false; } else ctx.lineTo(sx, sy);
    }
    ctx.stroke(); ctx.restore();
}

function drawDot(x, y) {
    const [sx, sy] = toScreen(x, y);
    ctx.fillStyle = getVar('--bg-body'); ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = getVar('--text-main'); ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
}

function drawVertical(val, color, label) {
    const [sx, sy] = toScreen(val, 0);
    ctx.save(); ctx.beginPath(); ctx.rect(60,60,canvas.width-120,canvas.height-120); ctx.clip();
    ctx.setLineDash([5,5]); ctx.strokeStyle = color;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.height); ctx.stroke();
    // Only label if meaningful position
    if(label && sx > 70 && sx < canvas.width-70) {
        ctx.fillStyle = color; ctx.fillText(label, sx+5, 75);
    }
    ctx.restore();
}

function drawGrid() {
    const pad = 60; const w = canvas.width; const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    const [ox, oy] = toScreen(0,0);
    ctx.strokeStyle = getVar('--axis-line'); ctx.lineWidth = 2; 
    ctx.beginPath(); ctx.moveTo(ox, pad); ctx.lineTo(ox, h-pad); ctx.moveTo(pad, oy); ctx.lineTo(w-pad, oy); ctx.stroke();
    
    ctx.fillStyle = getVar('--text-main'); ctx.font = "bold 12px sans-serif";
    let xL="Output (Y)", yL="Interest Rate (r%)";
    if(state.model === 'adas') yL = "Price Level (P)";
    if(state.model === 'phillips') { xL="Unemployment (u%)"; yL="Inflation (œÄ%)"; }
    if(state.model === 'solow') { xL="Capital per eff. worker (k)"; yL="Output per eff. worker (y)"; }
    if(state.model === 'mundell') { xL="Output (Y)"; yL="Exchange Rate (e)"; }
    
    ctx.fillText(xL, w-80, oy+35); ctx.fillText(yL, ox-10, pad-10);
}

/* ==========================================================================
   APP LOGIC
   ========================================================================== */
function update() {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    
    const m = MODELS[state.model];
    // Include horizon in state passed to solve
    state.horizon = state.horizon || 'short';
    const sol = m.solve(state);
    
    // Ghost Logic
    let prevSol = null;
    if(prevState) {
         const ps = JSON.parse(JSON.stringify(prevState));
         if(ps.G) ps.G = Math.min(200, Math.max(10, ps.G));
         // Ensure ghost uses same horizon unless we want to compare horizons (advanced)
         // For now, ghost uses its own captured horizon or current? 
         // Better to use current horizon for ghost comparison usually, or captured.
         ps.horizon = state.horizon; 
         prevSol = m.solve(ps);
    }
    
    calculateViewWindow(sol);
    drawGrid();
    if(prevSol) m.draw(prevSol, true);
    m.draw(sol, false);
    
    document.getElementById('math-display').innerHTML = m.explain(sol);
    document.getElementById('analysis-text').innerText = warningMsg || "Parameters within normal bounds.";
    if(warningMsg) document.getElementById('warning').style.display = 'block';
    else document.getElementById('warning').style.display = 'none';
    warningMsg = null;
    
    document.getElementById('legend-content').innerHTML = m.legend.map(i => 
        `<div class="legend-item"><div class="legend-line" style="background:${i.color}; border-bottom:${i.dashed?'2px dashed':'none'}"></div>${i.label}</div>`
    ).join('');
    
    let stats = [];
    if(sol.type === 'phillips') stats = [['u', sol.u.toFixed(1)+'%'], ['œÄ', sol.Pi.toFixed(2)+'%']];
    else if(sol.type === 'solow') stats = [['k', sol.k_curr.toFixed(1)], ['y', sol.y_curr.toFixed(2)]];
    else if(sol.type === 'mundell') stats = [['Y', sol.Y.toFixed(1)], ['e', sol.e.toFixed(2)]];
    else stats = [['Y', sol.Y.toFixed(1)], ['r', (sol.r||state.rs).toFixed(2)+'%']];
    
    document.getElementById('stats').innerHTML = stats.map(s => 
        `<div class="stat-box"><div class="stat-label">${s[0]}</div><div class="stat-num">${s[1]}</div></div>`
    ).join('');
    
    if(window.MathJax) MathJax.typesetPromise();
}

function stepSim() {
    if(MODELS[state.model].step) MODELS[state.model].step();
}

function switchModel(id, btnElement) {
    state = JSON.parse(JSON.stringify(DEFAULTS[id]));
    state.model = id; 
    // Default horizon reset
    state.horizon = 'short';
    
    prevState = JSON.parse(JSON.stringify(DEFAULTS[id]));
    
    document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
    if(btnElement) btnElement.classList.add('active');
    
    const hasSim = (id === 'adas' || id === 'solow' || id === 'phillips');
    document.getElementById('sim-ctrl').style.display = hasSim ? 'flex' : 'none';
    document.getElementById('horizon-ctrl').style.display = (id === 'islm' || id === 'adas') ? 'flex' : 'none';
    
    // Reset horizon tabs UI
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('.tab-btn').classList.add('active'); // First one (Short)
    
    updateControls();
    
    const sDiv = document.getElementById('scenarios'); sDiv.innerHTML = '';
    MODELS[id].scenarios.forEach(sc => {
        const b = document.createElement('button'); b.className = 'scenario-btn'; b.innerText = sc.name;
        b.onclick = () => {
            prevState = JSON.parse(JSON.stringify(state));
            Object.assign(state, sc.apply);
            updateControls(); update();
        };
        sDiv.appendChild(b);
    });
    update();
}

function setHorizon(h, btn) {
    state.horizon = h;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    if(btn) btn.classList.add('active');
    update();
}

function updateControls() {
    const cDiv = document.getElementById('controls'); cDiv.innerHTML = '';
    
    if(state.model === 'islm') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Open Econ (Imp Leakage)</span>
        <label class="switch"><input type="checkbox" ${state.isOpen?'checked':''} onchange="state.isOpen=this.checked; update()"><span class="slider"></span></label></div>`;
    }
    if(state.model === 'mundell') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Fixed Ex. Rate</span>
        <label class="switch"><input type="checkbox" ${state.regime==='fixed'?'checked':''} onchange="state.regime=this.checked?'fixed':'float'; update()"><span class="slider"></span></label></div>`;
    }
    if(state.model === 'phillips') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Adaptive Expectations</span>
        <label class="switch"><input type="checkbox" ${state.adaptive?'checked':''} onchange="state.adaptive=this.checked; update()"><span class="slider"></span></label></div>`;
    }

    const keys = Object.keys(state).filter(k => k!=='model' && k!=='isOpen' && k!=='regime' && k!=='adaptive' && k!=='k' && k!=='P' && k!=='horizon');
    const ranges = {
        G:[10,200,1], T:[10,200,1], M:[10,200,1], Pe:[0.5,5.0,0.1],
        s:[0.1,0.6,0.01], d:[0.05,0.2,0.01], n:[0,0.1,0.005], g:[0,0.1,0.005], rs:[0,10,0.1],
        Pie:[0,10,0.1], Un:[2,10,0.1], demandGap:[-5,5,0.1], shock:[-5,5,0.1]
    };
    
    keys.forEach(key => {
        const r = ranges[key];
        if(!r) return;
        const d = document.createElement('div'); d.className = 'slider-group';
        d.innerHTML = `
            <div class="slider-header"><div class="label-wrap">${key}</div><span class="slider-val" id="val-${key}">${state[key]}</span></div>
            <input type="range" min="${r[0]}" max="${r[1]}" step="${r[2]}" value="${state[key]}" oninput="state['${key}']=parseFloat(this.value); document.getElementById('val-${key}').innerText=this.value; update();">`;
        cDiv.appendChild(d);
    });
}

function resetModel() {
    switchModel(state.model, document.querySelector(`button[onclick="switchModel('${state.model}', this)"]`));
}

window.addEventListener('resize', update);
switchModel('islm', document.querySelector('.model-btn.active'));

</script>
</body>
</html>
