<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MacroSim | Theoretical Core Update</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-body: #0f172a; --bg-panel: #1e293b; --bg-sidebar: #020617;
            --border: #334155; --text-main: #f1f5f9; --text-muted: #94a3b8;
            --accent: #6366f1; --warn: #f59e0b;
            --grid-line: #334155; --axis-line: #94a3b8;
        }
        :root.light-mode {
            --bg-body: #ffffff; --bg-panel: #f8fafc; --bg-sidebar: #f1f5f9;
            --border: #cbd5e1; --text-main: #0f172a; --text-muted: #475569;
            --grid-line: #e2e8f0; --axis-line: #64748b;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-body); color: var(--text-main); margin: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
        }
        header {
            height: 50px; padding: 0 20px; background-color: var(--bg-sidebar); border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .brand { font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 10px; }
        .tag { background: var(--accent); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; }
        .layout { display: flex; flex: 1; height: calc(100vh - 50px); }
        .sidebar {
            width: 360px; background-color: var(--bg-sidebar); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; overflow-y: auto;
        }
        .section-title {
            padding: 16px 20px 8px; font-size: 0.7rem; text-transform: uppercase;
            color: var(--text-muted); font-weight: 700; letter-spacing: 1px; border-top: 1px solid var(--border);
        }
        .section-title:first-child { border-top: none; }
        .model-list { list-style: none; padding: 0; margin: 0; }
        .model-btn {
            width: 100%; text-align: left; padding: 12px 20px; background: transparent; border: none;
            color: var(--text-muted); cursor: pointer; border-left: 3px solid transparent; font-size: 0.9rem;
            transition: all 0.2s;
        }
        .model-btn:hover { background: var(--bg-panel); color: var(--text-main); }
        .model-btn.active { background: var(--bg-panel); color: var(--text-main); border-left-color: var(--accent); font-weight: 600; }
        
        .controls-container { padding: 10px 20px; }
        .slider-group { margin-bottom: 16px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; margin-bottom: 8px; }
        .label-wrap { display: flex; align-items: center; gap: 8px; }
        .info-btn {
            display: inline-flex; align-items: center; justify-content: center; width: 14px; height: 14px;
            border-radius: 50%; background: var(--border); color: var(--text-muted); font-size: 10px; font-weight: bold;
            font-family: serif; font-style: italic; cursor: help; position: relative;
        }
        .info-btn:hover { background: var(--accent); color: white; }
        .tooltip-box {
            position: absolute; bottom: 120%; left: -10px; background: var(--bg-sidebar); border: 1px solid var(--border);
            color: var(--text-main); padding: 10px; border-radius: 6px; font-size: 0.75rem; width: 240px;
            z-index: 1000; display: none; box-shadow: 0 10px 25px rgba(0,0,0,0.2); pointer-events: none; line-height: 1.4;
        }
        .info-btn:hover .tooltip-box { display: block; }
        .slider-val { font-family: monospace; color: var(--accent); }
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; padding: 0 5px; }
        .toggle-label { font-size: 0.8rem; color: var(--text-main); }
        .switch { position: relative; display: inline-block; width: 34px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border); transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(14px); }

        .scenario-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; padding: 0 20px 20px; }
        .scenario-btn {
            background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-muted); padding: 8px;
            border-radius: 6px; font-size: 0.7rem; cursor: pointer; transition: all 0.2s; text-align: center;
        }
        .scenario-btn:hover { border-color: var(--accent); color: var(--text-main); background: var(--border); }
        
        .action-btn {
            width: 100%; margin-bottom: 10px; padding: 10px; background: var(--accent);
            border: none; color: white; cursor: pointer; border-radius: 6px;
            font-size: 0.8rem; font-weight: 600; transition: all 0.2s;
        }
        .action-btn:hover { opacity: 0.9; }
        .reset-btn {
            width: calc(100% - 40px); margin: 0 20px 20px 20px; padding: 10px; background: transparent;
            border: 1px dashed var(--border); color: var(--text-muted); cursor: pointer; border-radius: 6px;
            font-size: 0.8rem; transition: all 0.2s;
        }
        .reset-btn:hover { border-color: var(--accent); color: var(--text-main); background: rgba(99, 102, 241, 0.1); }
        
        .viz-panel {
            flex: 2; position: relative; display: flex; flex-direction: column; background: var(--bg-body); overflow: hidden;
            transition: background-color 0.3s;
        }
        .sim-controls {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            display: flex; gap: 8px;
        }
        .sim-btn {
            background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-main);
            padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border-radius: 6px; font-weight: 600;
        }
        .sim-btn:hover { background: var(--accent); color: white; border-color: var(--accent); }
        
        canvas { width: 100%; height: 100%; }
        .edu-panel {
            width: 320px; background-color: var(--bg-body); border-left: 1px solid var(--border);
            display: flex; flex-direction: column; overflow-y: auto; padding: 20px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .edu-card { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .edu-title { font-weight: 700; font-size: 0.85rem; margin-bottom: 10px; color: var(--text-main); border-bottom: 1px solid var(--border); padding-bottom: 8px; }
        .math-block { font-size: 0.8rem; color: var(--text-muted); line-height: 1.6; overflow-x: auto; }
        .analysis-text { font-size: 0.85rem; color: var(--text-muted); line-height: 1.5; }
        .stats-overlay { position: absolute; top: 15px; right: 15px; display: flex; gap: 10px; z-index: 10; }
        .stat-box { background: var(--bg-panel); border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; text-align: right; box-shadow: 0 4px 6px rgba(0,0,0,0.1); opacity: 0.95; }
        .stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
        .stat-num { font-size: 0.95rem; font-weight: 700; color: var(--text-main); font-family: monospace; }
        .warning-banner {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            background: rgba(245, 158, 11, 0.15); border: 1px solid var(--warn); color: var(--warn);
            padding: 8px 16px; border-radius: 99px; font-size: 0.75rem; font-weight: 600;
            pointer-events: none; display: none; backdrop-filter: blur(4px);
        }
        #legend-content { display: flex; flex-direction: column; gap: 8px; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 0.8rem; color: var(--text-muted); }
        .legend-line { width: 16px; height: 3px; border-radius: 2px; }
        .creator-mark { margin-top: auto; padding-top: 20px; text-align: right; font-size: 10px; color: var(--text-muted); opacity: 0.5; font-family: serif; font-style: italic; letter-spacing: 0.5px; }
        .theme-toggle {
            background: transparent; border: 1px solid var(--border); color: var(--text-main);
            padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; margin-right: 15px;
            display: flex; align-items: center; gap: 6px;
        }
        .theme-toggle:hover { background: var(--bg-panel); }
    </style>
</head>
<body>

<header>
    <div class="brand">
        <div class="brand-icon">üìà</div>
        MACRO SIMULATOR <span class="tag">v19.0</span>
    </div>
    <div style="display:flex; align-items:center;">
        <button class="theme-toggle" id="theme-btn" onclick="toggleTheme()">‚òÄÔ∏è Projector Mode</button>
    </div>
</header>

<div class="layout">
    <nav class="sidebar">
        <div class="section-title">Select Model</div>
        <ul class="model-list">
            <li><button class="model-btn active" onclick="switchModel('islm')">IS-LM Model</button></li>
            <li><button class="model-btn" onclick="switchModel('adas')">AD-AS Model</button></li>
            <li><button class="model-btn" onclick="switchModel('phillips')">Phillips Curve</button></li>
            <li><button class="model-btn" onclick="switchModel('solow')">Solow Growth</button></li>
            <li><button class="model-btn" onclick="switchModel('mundell')">Mundell-Fleming</button></li>
        </ul>
        <div class="section-title">Parameters</div>
        <div class="controls-container" id="controls"></div>
        <div class="section-title">Quick Scenarios</div>
        <div class="scenario-grid" id="scenarios"></div>
        <button class="reset-btn" onclick="resetModel()">‚ü≤ Reset to Baseline</button>
    </nav>

    <main class="viz-panel">
        <div class="sim-controls" id="sim-ctrl" style="display:none;">
            <button class="sim-btn" onclick="stepSim()">‚ñ∂ Evolve Expect./Capital</button>
        </div>
        <div class="stats-overlay" id="stats"></div>
        <div class="warning-banner" id="warning">‚ö†Ô∏è Parameter Warning</div>
        <canvas id="canvas"></canvas>
    </main>

    <aside class="edu-panel">
        <div class="edu-card">
            <div class="edu-title">Theory & Derivation</div>
            <div class="math-block" id="math-display"></div>
        </div>
        <div class="edu-card">
            <div class="edu-title">Equilibrium Analysis</div>
            <div class="analysis-text" id="analysis-text"></div>
        </div>
        <div class="edu-card">
            <div class="edu-title">Legend</div>
            <div id="legend-content"></div>
        </div>
        <div class="creator-mark">Created by Bence Rudolph</div>
    </aside>
</div>

<script>
/* ==========================================================================
   THEME & UTILS
   ========================================================================== */
function toggleTheme() {
    const root = document.documentElement;
    const btn = document.getElementById('theme-btn');
    if (root.classList.contains('light-mode')) {
        root.classList.remove('light-mode'); btn.innerText = "‚òÄÔ∏è Projector Mode";
    } else {
        root.classList.add('light-mode'); btn.innerText = "üåô Dark Mode";
    }
    update();
}
function getVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* ==========================================================================
   GLOBAL CONSTANTS & STATE
   ========================================================================== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

/* ECONOMIC PARAMETERS 
   b: Investment sensitivity (lowered to 10 for graphical stability)
   m: Marginal propensity to import
   beta: Phillips curve slope
*/
const PARAMS = { 
    c1: 0.75, c0: 10, I0: 20, b: 10, k: 0.5, h: 2.0, Yn: 100, 
    m: 0.15, X0: 20, beta: 0.5, alpha: 0.33 
};

const DEFAULTS = {
    islm: { G: 70, T: 60, M: 50, isOpen: false }, // G adjusted for center view
    adas: { G: 60, M: 50, Pe: 1.0, P: 1.0 },      // Added P state for adaptive exp
    solow: { s: 0.3, d: 0.1, n: 0.02, g: 0.02, k: 20 }, // Added g, k state
    mundell: { G: 60, M: 50, rs: 4.0, regime: 'float' },
    phillips: { Pie: 2.0, Un: 5.0, demandGap: 0, shock: 0.0, adaptive: false }
};

let state = JSON.parse(JSON.stringify(DEFAULTS.islm));
state.model = 'islm';
let prevState = null;
let view = { maxX: 350, maxY: 25 }; 
let warningMsg = null;

/* ==========================================================================
   MODEL ENGINES
   ========================================================================== */
const MODELS = {
    islm: {
        name: "IS-LM (Keynesian)",
        legend: [
            {label: 'IS Curve', color: '#3b82f6'},
            {label: 'LM Curve', color: '#ef4444'},
            {label: 'Liquidity Trap', color: '#ef4444', dashed: true}
        ],
        scenarios: [
            { name: "Fiscal Stimulus", apply: {G:120} },
            { name: "Monetary Tightening", apply: {M:25} },
            { name: "Liquidity Trap Case", apply: {M:120, G:30} }
        ],
        solve: (st) => {
            let { G, T, M, isOpen } = st;
            G=Math.min(200,Math.max(10,G)); M=Math.max(10,M);
            
            // IS Curve: Y = Multiplier * (Autonomous - b*r)
            // Closed: Mult = 1/(1-c1). Open: Mult = 1/(1-c1+m) with NX leakage
            const { c1, c0, I0, b, m, X0 } = PARAMS;
            const mult = isOpen ? 1/(1 - c1 + m) : 1/(1 - c1);
            const Aut = c0 + I0 + G - c1*T + (isOpen ? X0 : 0);
            
            // LM Curve: r = max(0.1, (kY - M)/h)  <-- LIQUIDITY TRAP LOGIC
            // To solve Equilibrium: Substitute r in IS. 
            // Case 1: Normal. r = (kY - M)/h
            // Y = mult(Aut - b((kY-M)/h)) => Y(1 + mult*b*k/h) = mult(Aut + bM/h)
            const denom = 1 + (mult * b * PARAMS.k) / PARAMS.h;
            const num = mult * (Aut + (b * M)/PARAMS.h);
            let Y = num / denom;
            let r = (PARAMS.k*Y - M)/PARAMS.h;
            
            // Case 2: Trap Check. If calc r < 0.1, set r=0.1 and solve IS for Y
            if(r < 0.1) {
                r = 0.1;
                Y = mult * (Aut - b*r);
                warningMsg = "Liquidity Trap: Mon. Policy Ineffective";
            }
            
            return { Y, r, Aut, mult, M, type: 'islm' };
        },
        draw: (sol, isGhost) => {
            const sIS = isGhost ? 'ghost' : 'is';
            const sLM = isGhost ? 'ghost' : 'lm';
            
            // Draw IS
            drawCurve(y => (sol.Aut - y/sol.mult)/PARAMS.b, sIS, isGhost?'IS‚ÇÄ':'IS‚ÇÅ');
            
            // Draw Piecewise LM
            // Flat at 0.1% until Y = (M + h*0.1)/k, then upward sloping
            const kinkY = (sol.M + PARAMS.h*0.1)/PARAMS.k;
            drawCurve(y => {
                if(y < kinkY) return 0.1;
                return (PARAMS.k*y - sol.M)/PARAMS.h;
            }, sLM, isGhost?'LM‚ÇÄ':'LM‚ÇÅ');
            
            if(!isGhost) drawDot(sol.Y, sol.r);
        },
        explain: (sol) => `$$ IS: Y = ${sol.mult.toFixed(2)}(A - ${PARAMS.b}r) \\quad [NX = ${state.isOpen?'X_0 - mY':0}] $$
                           $$ LM: r = \\max(0.1\\%, \\frac{kY - M}{h}) $$`
    },

    adas: {
        name: "AD-AS (Dynamic)",
        legend: [
            {label: 'AD Curve', color: '#10b981'},
            {label: 'SRAS Curve', color: '#f59e0b'},
            {label: 'LRAS (Yn)', color: '#94a3b8', dashed: true}
        ],
        scenarios: [
            { name: "Demand Shock", apply: {G:100} },
            { name: "Supply Shock", apply: {Pe: 2.0} } // Sets initial expectation higher
        ],
        solve: (st) => {
            // AD derived from IS-LM (Closed for simplicity here)
            // Y = AD(P). From IS-LM: Y = (mult*A + mult*b*M/h*P) / (1 + ...)
            // Simplified AD: Y = Y_aut + alpha * (M/P)
            const { c1, c0, I0, b, k, h, Yn } = PARAMS;
            const mult = 1/(1-c1);
            const Aut = c0 + I0 + st.G - c1*DEFAULTS.islm.T; // Use fixed T
            
            // Reduced form AD coefficients
            const theta = (h + b*k*mult); 
            const term1 = (h * mult * Aut) / theta; // Autonomous part
            const term2 = (b * mult * st.M) / theta; // Monetary part
            
            // SRAS: P = Pe + lambda(Y - Yn)  => Y = Yn + (P - Pe)/lambda
            const lambda = 0.5;
            
            // Solve System: P = Pe + lambda( (term1 + term2/P) - Yn )
            // This is quadratic in P.
            // lambda*term2/P + (lambda*(term1-Yn) + Pe) - P = 0
            // Rearrange: P^2 - P(Pe + lambda(term1-Yn)) - lambda*term2 = 0
            const B_quad = st.Pe + lambda*(term1 - Yn);
            const C_quad = -lambda * term2;
            const P_eq = (B_quad + Math.sqrt(B_quad*B_quad - 4*1*C_quad)) / 2;
            const Y_eq = term1 + term2/P_eq;

            return { Y: Y_eq, P: P_eq, term1, term2, Pe: st.Pe, type:'adas' };
        },
        step: () => {
            // Adaptive Expectations: Pe_new = Pe_old + gamma(P_actual - Pe_old)
            const sol = MODELS.adas.solve(state);
            const gamma = 0.5; // Speed of adjustment
            state.Pe = state.Pe + gamma * (sol.P - state.Pe);
            // Stop jitter if close
            if(Math.abs(sol.P - state.Pe) < 0.01) state.Pe = sol.P;
            update();
        },
        draw: (sol, isGhost) => {
            // Draw AD: P vs Y (inverted for drawing y=f(x))
            // P = term2 / (Y - term1)
            drawCurve(y => {
                let den = y - sol.term1;
                return den > 0.1 ? sol.term2/den : null;
            }, isGhost?'ghost':'ad', isGhost?'AD‚ÇÄ':'AD‚ÇÅ');
            
            // Draw SRAS: P = Pe + lambda(Y - Yn)
            drawCurve(y => sol.Pe + 0.5*(y - PARAMS.Yn), isGhost?'ghost':'as', isGhost?'SRAS‚ÇÄ':'SRAS‚ÇÅ');
            
            drawVertical(PARAMS.Yn, '#94a3b8', 'LRAS');
            if(!isGhost) drawDot(sol.Y, sol.P);
        },
        explain: (sol) => `$$ P = P^e + \\lambda(Y - Y_n) \\quad [P^e = ${sol.Pe.toFixed(2)}] $$ 
                           $$ Y = AD(G, M/P) $$`
    },

    phillips: {
        name: "Phillips Curve",
        legend: [
            {label: 'Short-Run PC', color: '#ef4444'},
            {label: 'Long-Run PC', color: '#3b82f6', dashed: true}
        ],
        scenarios: [
            { name: "Demand Boom", apply: {demandGap: 3.0} },
            { name: "Supply Shock", apply: {shock: 2.0} }
        ],
        solve: (st) => {
            // 1. Determine U from Demand Gap (Okun's Law Proxy)
            // u = Un - 0.5 * (Y_gap)
            // User controls 'demandGap' directly for pedagogical clarity
            const u = st.Un - 0.5 * st.demandGap;
            
            // 2. Phillips Curve
            // pi = Pie - beta(u - Un) + shock
            const Pi = st.Pie - PARAMS.beta*(u - st.Un) + st.shock;
            
            return { u, Pi, Pie: st.Pie, Un: st.Un, type:'phillips' };
        },
        step: () => {
            if(state.adaptive) {
                // Adaptive: Pie_new = Pi_actual (Lagged inflation)
                const sol = MODELS.phillips.solve(state);
                state.Pie = sol.Pi;
                update();
            }
        },
        draw: (sol, isGhost) => {
            // PC: Pi = (Pie + shock + beta*Un) - beta*u
            const intercept = sol.Pie + state.shock + PARAMS.beta*sol.Un;
            drawCurve(u => intercept - PARAMS.beta*u, isGhost?'ghost':'lm', isGhost?'PC‚ÇÄ':'PC‚ÇÅ');
            drawVertical(sol.Un, '#3b82f6', 'LRPC');
            if(!isGhost) drawDot(sol.u, sol.Pi);
        },
        explain: (sol) => `$$ \\pi_t = \\pi^e_{t} - \\beta(u_t - u_n) + \\nu_t $$
                           $$ \\text{Exp: } ${state.adaptive ? "\\pi^e_t = \\pi_{t-1} (Adaptive)" : "\\pi^e = \\bar{\\pi} (Static)"} $$`
    },

    solow: {
        name: "Solow-Swan",
        legend: [
            {label: 'Investment sf(k)', color: '#10b981'},
            {label: 'Break-even (Œ¥+n+g)k', color: '#ef4444'}
        ],
        scenarios: [
            { name: "Savings Boom", apply: {s: 0.5} },
            { name: "Tech Growth", apply: {g: 0.05} }
        ],
        solve: (st) => {
            // Steady State Calculation
            // sf(k) = (d + n + g)k  => s k^alpha = effDep * k
            // k^(alpha-1) = effDep/s => k* = (s/effDep)^(1/(1-alpha))
            const effDep = st.d + st.n + st.g;
            const k_star = Math.pow(st.s/effDep, 1/(1-PARAMS.alpha));
            
            // Actual current y based on state.k (for dynamics)
            const y_curr = Math.pow(st.k, PARAMS.alpha);
            
            return { k_star, effDep, k_curr: st.k, y_curr, type:'solow' };
        },
        step: () => {
            // Capital Accumulation: dk = s*y - (d+n+g)k
            const sol = MODELS.solow.solve(state);
            const dk = state.s * sol.y_curr - sol.effDep * state.k;
            state.k += dk * 1.5; // Speed multiplier
            update();
        },
        draw: (sol, isGhost) => {
            // Investment Curve: s * k^alpha
            drawCurve(k => state.s * Math.pow(k, PARAMS.alpha), isGhost?'ghost':'ad', 'sf(k)');
            // Break-even Line: (d+n+g)k
            drawCurve(k => sol.effDep * k, isGhost?'ghost':'lm', '(Œ¥+n+g)k');
            
            // Draw current K (Dynamic)
            if(!isGhost) {
                drawDot(sol.k_curr, state.s * Math.pow(sol.k_curr, PARAMS.alpha));
                // Draw Steady State phantom
                const y_star = state.s * Math.pow(sol.k_star, PARAMS.alpha);
                ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); 
                const [sx, sy] = toScreen(sol.k_star, y_star);
                ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
            }
        },
        explain: (sol) => `$$ \\Delta k = s f(k) - (\\delta + n + g)k $$
                           $$ k^* = ${sol.k_star.toFixed(1)} \\quad (\\text{Current } k = ${sol.k_curr.toFixed(1)}) $$`
    },

    mundell: {
        name: "Mundell-Fleming (SOE)",
        legend: [
            {label: 'IS* Curve', color: '#3b82f6'},
            {label: 'LM* Curve (r=r*)', color: '#ef4444'}
        ],
        scenarios: [
            { name: "Fiscal Exp. (Float)", apply: {G:100, regime:'float'} },
            { name: "Fiscal Exp. (Fixed)", apply: {G:100, regime:'fixed'} }
        ],
        solve: (st) => {
            // IS: Y = C(Y-T) + I(r*) + G + NX(e)
            // In linear form: Y(1-c1) = Aut - b*r* + NX_aut - q*e
            // Solve for e (Float) or Y (Fixed)
            
            const { c1, c0, I0, b, X0 } = PARAMS;
            const Aut = c0 + I0 + st.G - c1*DEFAULTS.islm.T;
            const r_star = st.rs; 
            const q = 2; // Exchange rate sensitivity
            
            let Y, e, M_endo;

            if(st.regime === 'float') {
                // Float: M is exogenous. LM determines Y.
                // LM: M/P = kY - h*r* => Y = (M + h*r*)/k
                Y = (st.M + PARAMS.h*r_star) / PARAMS.k;
                
                // IS determines e given Y
                // Y(1-c1) = Aut - b*r* + X0 - q*e
                // q*e = Aut - b*r* + X0 - Y(1-c1)
                e = (Aut - b*r_star + X0 - Y*(1-c1)) / q;
                M_endo = st.M;
            } else {
                // Fixed: e is fixed. IS determines Y.
                e = 3.0; // Pegged rate
                // Y(1-c1) = Aut - b*r* + X0 - q*e
                Y = (Aut - b*r_star + X0 - q*e) / (1-c1);
                
                // LM determines M endogenously
                M_endo = PARAMS.k*Y - PARAMS.h*r_star;
            }

            return { Y, e, r: r_star, M: M_endo, regime: st.regime, type:'mundell' };
        },
        draw: (sol, isGhost) => {
            // Draw horizontal LM* at r = r*
            drawCurve(y => sol.r, isGhost?'ghost':'lm', isGhost?'LM*‚ÇÄ':'LM*‚ÇÅ');
            
            // Draw downward IS* in (Y, r) space? 
            // PROBLEM: MF is usually plotted Y vs e or Y vs r.
            // Standard text (Mankiw) plots Y vs e.
            // But our canvas engine is set up for Y vs "Value".
            // Let's plot Y vs r (IS-LM diagram) but with Horizontal LM*.
            // The IS curve shifts depending on e.
            
            // Re-calc IS curve for drawing: r = (Aut + NX(e) - Y(1-c1))/b
            const q = 2;
            const NX_val = PARAMS.X0 - q*sol.e;
            const { c1, c0, I0, b } = PARAMS;
            const A_total = c0 + I0 + state.G - c1*60 + NX_val; // approx A
            
            drawCurve(y => (A_total - y*(1-c1))/b, isGhost?'ghost':'is', isGhost?'IS*‚ÇÄ':'IS*‚ÇÅ');
            
            if(!isGhost) drawDot(sol.Y, sol.r);
        },
        explain: (sol) => {
            const effect = sol.regime === 'float' 
                ? "Crowding Out via Apprec." 
                : "Monetary Accomodation";
            return `$$ r = r^* = ${sol.r}\\% \\quad (${sol.regime.toUpperCase()}) $$
                    $$ e = ${sol.e.toFixed(2)} \\quad Y = ${sol.Y.toFixed(1)} $$`;
        }
    }
};

/* ==========================================================================
   VIEW & CONTROLS
   ========================================================================== */
function calculateViewWindow(sol) {
    // Custom Viewports
    if(sol.type === 'solow') { view.maxX = 60; view.maxY = 6; }
    else if(sol.type === 'phillips') { view.maxX = 12; view.maxY = 10; } // u vs pi
    else if(sol.type === 'adas') { view.maxX = 300; view.maxY = 5; }
    else { view.maxX = 350; view.maxY = 15; } // ISLM / MF
}

function toScreen(x, y) {
    const pad = 60; const w = canvas.width; const h = canvas.height;
    const sX = pad + (x / view.maxX) * (w - 2*pad);
    const sY = (h - pad) - (y / view.maxY) * (h - 2*pad);
    return [sX, sY];
}

function drawCurve(func, style, label) {
    const colors = { is: '#3b82f6', lm: '#ef4444', ad: '#10b981', as: '#f59e0b', ghost: '#475569' };
    const pad = 60;
    ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, canvas.width-2*pad, canvas.height-2*pad); ctx.clip();
    ctx.beginPath(); ctx.strokeStyle = colors[style] || '#fff';
    ctx.lineWidth = style === 'ghost' ? 2 : 3;
    if(style === 'ghost') ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
    
    let start = true;
    for(let i = 0; i <= 400; i++) {
        const x = (i/400) * view.maxX;
        const y = func(x);
        if(y === null || !isFinite(y) || y < -5 || y > view.maxY*1.5) { start=true; continue; }
        const [sx, sy] = toScreen(x, y);
        if(start) { ctx.moveTo(sx, sy); start=false; } else ctx.lineTo(sx, sy);
    }
    ctx.stroke(); ctx.restore();
}

function drawDot(x, y) {
    const [sx, sy] = toScreen(x, y);
    ctx.fillStyle = getVar('--bg-body'); ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = getVar('--text-main'); ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
}

function drawVertical(val, color, label) {
    const [sx, sy] = toScreen(val, 0);
    ctx.save(); ctx.beginPath(); ctx.rect(60,60,canvas.width-120,canvas.height-120); ctx.clip();
    ctx.setLineDash([5,5]); ctx.strokeStyle = color;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, canvas.height); ctx.stroke();
    ctx.restore();
}

function drawGrid() {
    const pad = 60; const w = canvas.width; const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    
    // Axes
    const [ox, oy] = toScreen(0,0);
    ctx.strokeStyle = getVar('--axis-line'); ctx.lineWidth = 2; 
    ctx.beginPath(); ctx.moveTo(ox, pad); ctx.lineTo(ox, h-pad); ctx.moveTo(pad, oy); ctx.lineTo(w-pad, oy); ctx.stroke();
    
    // Labels
    ctx.fillStyle = getVar('--text-main'); ctx.font = "bold 12px sans-serif";
    let xL="Output (Y)", yL="Interest Rate (r)";
    if(state.model === 'adas') yL = "Price Level (P)";
    if(state.model === 'phillips') { xL="Unemployment (u)"; yL="Inflation (œÄ)"; }
    if(state.model === 'solow') { xL="Capital (k)"; yL="Output (y)"; }
    
    ctx.fillText(xL, w-80, oy+35); ctx.fillText(yL, ox-10, pad-10);
}

/* ==========================================================================
   APP LOGIC
   ========================================================================== */
function update() {
    canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight;
    
    const m = MODELS[state.model];
    const sol = m.solve(state);
    
    let prevSol = null;
    if(prevState) {
         // Safe copy for ghost
         const ps = JSON.parse(JSON.stringify(prevState));
         // Enforce bounds on ghost too
         if(ps.G) ps.G = Math.min(200, Math.max(10, ps.G));
         prevSol = m.solve(ps);
    }
    
    calculateViewWindow(sol);
    drawGrid();
    if(prevSol) m.draw(prevSol, true);
    m.draw(sol, false);
    
    // Update text
    document.getElementById('math-display').innerHTML = m.explain(sol);
    document.getElementById('analysis-text').innerText = warningMsg || "Parameters within normal bounds.";
    if(warningMsg) document.getElementById('warning').style.display = 'block';
    else document.getElementById('warning').style.display = 'none';
    warningMsg = null;
    
    // Legend
    document.getElementById('legend-content').innerHTML = m.legend.map(i => 
        `<div class="legend-item"><div class="legend-line" style="background:${i.color}; border-bottom:${i.dashed?'2px dashed':'none'}"></div>${i.label}</div>`
    ).join('');
    
    // Stats
    let stats = [];
    if(sol.type === 'phillips') stats = [['u', sol.u.toFixed(1)+'%'], ['œÄ', sol.Pi.toFixed(2)+'%']];
    else if(sol.type === 'solow') stats = [['k', sol.k_curr.toFixed(1)], ['y', sol.y_curr.toFixed(2)]];
    else stats = [['Y', sol.Y.toFixed(1)], ['r', (sol.r||state.rs).toFixed(2)+'%']];
    
    document.getElementById('stats').innerHTML = stats.map(s => 
        `<div class="stat-box"><div class="stat-label">${s[0]}</div><div class="stat-num">${s[1]}</div></div>`
    ).join('');
    
    if(window.MathJax) MathJax.typesetPromise();
}

function stepSim() {
    if(MODELS[state.model].step) MODELS[state.model].step();
}

function switchModel(id) {
    state = JSON.parse(JSON.stringify(DEFAULTS[id]));
    state.model = id; prevState = null;
    
    document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    
    // Show/Hide Sim Button
    const hasSim = (id === 'adas' || id === 'solow' || id === 'phillips');
    document.getElementById('sim-ctrl').style.display = hasSim ? 'flex' : 'none';
    
    updateControls();
    
    const sDiv = document.getElementById('scenarios'); sDiv.innerHTML = '';
    MODELS[id].scenarios.forEach(sc => {
        const b = document.createElement('button'); b.className = 'scenario-btn'; b.innerText = sc.name;
        b.onclick = () => {
            prevState = JSON.parse(JSON.stringify(state));
            Object.assign(state, sc.apply);
            updateControls(); update();
        };
        sDiv.appendChild(b);
    });
    update();
}

function updateControls() {
    const cDiv = document.getElementById('controls'); cDiv.innerHTML = '';
    
    // Toggles
    if(state.model === 'islm') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Open Econ (Imp Leakage)</span>
        <label class="switch"><input type="checkbox" ${state.isOpen?'checked':''} onchange="state.isOpen=this.checked; update()"><span class="slider"></span></label></div>`;
    }
    if(state.model === 'mundell') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Fixed Ex. Rate</span>
        <label class="switch"><input type="checkbox" ${state.regime==='fixed'?'checked':''} onchange="state.regime=this.checked?'fixed':'float'; update()"><span class="slider"></span></label></div>`;
    }
    if(state.model === 'phillips') {
        cDiv.innerHTML += `
        <div class="toggle-row"><span class="toggle-label">Adaptive Expectations</span>
        <label class="switch"><input type="checkbox" ${state.adaptive?'checked':''} onchange="state.adaptive=this.checked; update()"><span class="slider"></span></label></div>`;
    }

    // Sliders
    const keys = Object.keys(state).filter(k => k!=='model' && k!=='isOpen' && k!=='regime' && k!=='adaptive' && k!=='k' && k!=='P');
    const ranges = {
        G:[10,200,1], T:[10,200,1], M:[10,200,1], Pe:[0.5,5.0,0.1],
        s:[0.1,0.6,0.01], d:[0.05,0.2,0.01], n:[0,0.1,0.005], g:[0,0.1,0.005], rs:[0,10,0.1],
        Pie:[0,10,0.1], Un:[2,10,0.1], demandGap:[-5,5,0.1], shock:[-5,5,0.1]
    };
    
    keys.forEach(key => {
        const r = ranges[key];
        if(!r) return;
        const d = document.createElement('div'); d.className = 'slider-group';
        d.innerHTML = `
            <div class="slider-header"><div class="label-wrap">${key}</div><span class="slider-val" id="val-${key}">${state[key]}</span></div>
            <input type="range" min="${r[0]}" max="${r[1]}" step="${r[2]}" value="${state[key]}" oninput="state['${key}']=parseFloat(this.value); document.getElementById('val-${key}').innerText=this.value; update();">`;
        cDiv.appendChild(d);
    });
}

function resetModel() {
    switchModel(state.model);
}

window.addEventListener('resize', update);
switchModel('islm');

</script>
</body>
</html>
